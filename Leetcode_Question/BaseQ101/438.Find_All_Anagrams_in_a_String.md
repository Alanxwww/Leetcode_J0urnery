## Link
[Find All Anagrams in a String - LeetCode](https://leetcode.com/problems/find-all-anagrams-in-a-string/description/) - medium
## Question
> Given two strings `s` and `p`, return an array of all the start indices of `p`'s anagrams in `s`. You may return the answer in **any order**.
> 
> **Example 1:**
>> **Input:** `s = "cbaebabacd"`, `p = "abc"`
>> **Output:** `[0,6]`
>> **Explanation:**
>> - The substring with start index = 0 is `"cba"`, which is an anagram of "abc".
>> - The substring with start index = 6 is `"bac"`, which is an anagram of "abc".
## Goal
- find all starting index of substring `s` that are anagrams of `p`
## Logic
- Using the sliding window technique
1. Initialize two pointers, left and right to form a sliding window
2. while `right < len(s):`
	1. if `window size < len(p)`:
		- move the right pointer forward
	2. if `window size == len(p)`
		- compare
		- remove the `s[left]`
		- sliding window forward: left += 1, right += 1
## Code
```python
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        len_s, len_p = len(s), len(p)
        if len_s < len_p:
            return []

        res = []
        expect_freqs = [0] * 26
        window_freqs = [0] * 26
        for char in p:
            expect_freqs[ord(char) - ord('a')] += 1
        
        left = right = 0
        while right < len_s:
            window_freqs[ord(s[right]) - ord('a')] += 1

            if right - left + 1 == len_p:
                if window_freqs == expect_freqs:
                    res.append(left)
                window_freqs[ord(s[left]) - ord('a')] -= 1
                left += 1
            right += 1
        
        return res
```

## Complexity analysis
- Time Complexity: O(n)
- Space Complexity: O(1)
## Pre-knowledge
- Sliding windows
