## Link
[Permutations - LeetCode](https://leetcode.com/problems/permutations/description/) - medium
## Question
>Given an array `nums` of distinct integers, return all the possible permutations. You can return the answer in **any order**.
>
>**Example 1:**
>>**Input:** nums = `[1,2,3]`<br>
>>**Output:** `[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]`
>
>**Example 2:**
>>**Input:** nums = `[0,1]`<br>
>>**Output:** `[[0,1],[1,0]]`

## Goal:
- give more possible permutations
## Logic
- backtrack
- loop num
	1. for any unused number:
	2. add it to path
	3. recursive
	4. Backtrack: remove from path, unmark as used

## Code:
```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        res = []
        self.backtrack(nums, [], set(), res)
        return res
    
    def backtrack(self, nums, candidate, used, res):
        if len(nums) == len(candidate):
            res.append(candidate[:]) # copy the value
            return
        
        for i in nums:
            if i not in used:
                candidate.append(i)
                used.add(i)
                self.backtrack(nums, candidate, used, res)
                candidate.pop()
                used.remove(i)
```

## Complexity analysis
- Time Complexity: O(n!)
- Space Complexity: O(n)

## Hint for backtrack:
The `for` loop in backtracking is not just one iteration - it explores all possible decisions at the current recursion level. Each iteration represents a choice, and recursion explores the consequences of that choice.

Backtrack crude template:
```python
def def(state):
	if meets_termination_condition(state):
		process_solution(state)
		return
	
	for decision in possible_decision(state):
		make_decision(state, decision)	
		dfs(state)
		undo_decision(state)
```
