## Link
[Longest Increasing Path in a Matrix - LeetCode](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/description/) - medium
## Question
>Given an `m x n` integers `matrix`, return _the length of the longest increasing path in_ `matrix`.
>From each cell, you can either move in four directions: left, right, up, or down. You **may not** move **diagonally** or move **outside the boundary** (i.e., wrap-around is not allowed).
>
>Example1:
>>![[Pasted image 20250508122613.png|200]]
>>**Input:** matrix = `[[9,9,4],[6,6,8],[2,1,1]]`
>>**Output:** 4
>>**Explanation:** The longest increasing path is `[1, 2, 6, 9]`.

## Goal:
Find the longest path with increasing order.
## Logic
Approach: **DFS + Memorization**
1. Start from each cell
2. Create the memo matrix,
	- store the length of the longest increasing path start from cell
	- if `memo[r][c] != 0`, we can reuse the result instead of recomputing it. 
3. DFS function
	1. for current cell (r, c) explore its 4 neighbor
	2. move to a neighbor, only the value is greater
	3. for each valid neighbor, recursively compute the longest path and take the maximu,
	4. add `1` from the current cell and store the result in `memo[r][c]`
## Code:
```python
class Solution:
    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
        if not matrix:
            return 0

        res = 0
        m, n = len(matrix), len(matrix[0])
        memo = [[0] * m for _ in range(n)]
        for r in range(m):
            for c in range(n):
                res = max(res, self.dfs(r, c, matrix, memo))
        return res


    def dfs(self, r, c, matrix, memo):
        if memo[r][c] != 0:
            return memo[r][c]
        
        max_path = 1
        dirs = [(1, 0), (-1, 0), (0, -1), (0, 1)]
        for d in dirs:
            next_r, next_c = r + d[0], c + d[1]
            if (self.within_bounds(next_r, next_c, matrix)
                and matrix[next_r][next_c] > matrix[r][c]):
                max_path = max(max_path, 1 + self.dfs(next_r, next_c, matrix, memo))
        memo[r][c] = max_path
        return max_path

    def within_bounds(self, row, col, matrix):
        return 0 <= row < len(matrix) and 0 <= col < len(matrix[0])
```
## Complexity analysis
- Time Complexity: `O(m * n)`
- Space Complexity: `O(m * n)`
## Sample: 


## Pre-knowledge
- graph
