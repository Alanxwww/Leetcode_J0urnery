## Link
[Meet_Schedule_II - Neetcode](https://neetcode.io/problems/meeting-schedule-ii) - medium
## Question
> Given an array of meeting time interval objects consisting of start and end timesÂ `[[start_1,end_1],[start_2,end_2],...] (start_i < end_i)`, find the minimum number of days required to schedule all meetings without any conflicts.
> 
> **Example 1:**
>> Input: intervals = `[(0,40),(5,10),(15,20)]` <br>
>> Output: 2 <br>
>> Explanation: <br>
>> 	`day1: (0,40)`<br>
>> 	`day2: (5,10),(15,20)`<br>
## Goal
- Find the maximum number of overlapping intervals
## Logic
- use `sweeping line algorithm` to process interval start and end events.
1. Convert each interval into two events
2. Sort the event list
3. Sweep through events:
   - Keep a counter of active intervals.
   - Update `max_overlap` as the maximum value of this counter.
1. Return the max_overlap
## Code
```python
"""
Definition of Interval:
class Interval(object):
    def __init__(self, start, end):
        self.start = start
        self.end = end
"""
class Solution:
    def minMeetingRooms(self, intervals: List[Interval]) -> int:
        points = []
        for interval in intervals:
            points.append((interval.start, 'start'))
            points.append((interval.end, 'end'))
        
        points.sort(key=lambda x: (x[0], 1 if x[1] == 'start' else 0)) # end then start
        
        active_intervals = 0
        max_overlap = 0
        for time, point_type in points:
            if point_type == 'start':
                active_intervals += 1
            else:
                active_intervals -= 1
            max_overlap = max(max_overlap, active_intervals)
        
        return max_overlap      
```

## Complexity analysis
- Time Complexity: O(nlogn)
- Space Complexity: O(n)
## Pre-knowledge
- intervals
	- sweeping line algorithm
